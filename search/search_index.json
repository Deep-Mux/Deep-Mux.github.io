{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Deep Mux Official website DeepMux is a platform to deploy machine learning models into production. Our system allows you to use only as much GPU time as you really need. We automatically pick the best hardware that suits your model. Simply upload your model and get predictions, zero tweaking required.","title":"Overview"},{"location":"#welcome-to-deep-mux","text":"Official website DeepMux is a platform to deploy machine learning models into production. Our system allows you to use only as much GPU time as you really need. We automatically pick the best hardware that suits your model. Simply upload your model and get predictions, zero tweaking required.","title":"Welcome to Deep Mux"},{"location":"cli/","text":"Installing deepmux-cli DeepMux CLI allows to manage functions on DeepMux cloud platform. Pre-requisites Python Install Python 3.6 or newer. Follow the instruction here . Skip this step if you already have proper version of python installed. Pip We are going to use pip to install deepmux command line interface below. If you don't have pip available from the command line, follow this guide . Installing and configuring the package Install Use pip to install deepmux-cli : pip install deepmux-cli Login Go to the https://app.deepmux.com/api_key and copy your token. Then run: deepmux login And paste your token when prompted. Run --help to see the full list of options: deepmux --help That's it! If you have any questions or feedback please send it to dev@deepmux.com Check out other articles to get started with DeepMux platform.","title":"Installing deepmux-cli"},{"location":"cli/#installing-deepmux-cli","text":"DeepMux CLI allows to manage functions on DeepMux cloud platform.","title":"Installing deepmux-cli"},{"location":"cli/#pre-requisites","text":"","title":"Pre-requisites"},{"location":"cli/#python","text":"Install Python 3.6 or newer. Follow the instruction here . Skip this step if you already have proper version of python installed.","title":"Python"},{"location":"cli/#pip","text":"We are going to use pip to install deepmux command line interface below. If you don't have pip available from the command line, follow this guide .","title":"Pip"},{"location":"cli/#installing-and-configuring-the-package","text":"","title":"Installing and configuring the package"},{"location":"cli/#install","text":"Use pip to install deepmux-cli : pip install deepmux-cli","title":"Install"},{"location":"cli/#login","text":"Go to the https://app.deepmux.com/api_key and copy your token. Then run: deepmux login And paste your token when prompted. Run --help to see the full list of options: deepmux --help","title":"Login"},{"location":"cli/#thats-it","text":"If you have any questions or feedback please send it to dev@deepmux.com Check out other articles to get started with DeepMux platform.","title":"That's it!"},{"location":"details/","text":"Learn more Cold start Function call time time may increase after function has been idle for some time or is being called for the first time. It happens due to the fact that we need to load the functions before executing it. Time after which functons are unloaded is not fixed and is subject to constant adjustment. Think tens of seconds to minutes. Billing You are charged only for the call time and not for of infrastructure latency. Note that request times on the client may differ from the ones observed in billing due to network latency and throughput.","title":"Learn More"},{"location":"details/#learn-more","text":"","title":"Learn more"},{"location":"details/#cold-start","text":"Function call time time may increase after function has been idle for some time or is being called for the first time. It happens due to the fact that we need to load the functions before executing it. Time after which functons are unloaded is not fixed and is subject to constant adjustment. Think tens of seconds to minutes.","title":"Cold start"},{"location":"details/#billing","text":"You are charged only for the call time and not for of infrastructure latency. Note that request times on the client may differ from the ones observed in billing due to network latency and throughput.","title":"Billing"},{"location":"faq/","text":"FAQ What if my model is written in a framework that is not supported by DeepMux? We support models in ONNX format, which is quite universal. You can convert your model to ONNX and uplad it to deepmux. If it is not possible, feel free to contact us at dev@deepmux.com and we will figure out a solution for you. What if model has multiple inputs / outputs? To create a model with multiple inputs / outputs, you need to pass a list of shapes into input_shape and output_shape parameters. For example, [[2, 2], [1, 3]] would stand for two inputs of sizes 2x2 and 1x3 respectively. Are variable input / output sizes supported? Short answer would be: not yet. Nevertheless you can create a model and predefine it's expected input shape to resize your input before passing it to the model. Variable output shapes are not possible at the moment.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#what-if-my-model-is-written-in-a-framework-that-is-not-supported-by-deepmux","text":"We support models in ONNX format, which is quite universal. You can convert your model to ONNX and uplad it to deepmux. If it is not possible, feel free to contact us at dev@deepmux.com and we will figure out a solution for you.","title":"What if my model is written in a framework that is not supported by DeepMux?"},{"location":"faq/#what-if-model-has-multiple-inputs-outputs","text":"To create a model with multiple inputs / outputs, you need to pass a list of shapes into input_shape and output_shape parameters. For example, [[2, 2], [1, 3]] would stand for two inputs of sizes 2x2 and 1x3 respectively.","title":"What if model has multiple inputs / outputs?"},{"location":"faq/#are-variable-input-output-sizes-supported","text":"Short answer would be: not yet. Nevertheless you can create a model and predefine it's expected input shape to resize your input before passing it to the model. Variable output shapes are not possible at the moment.","title":"Are variable input / output sizes supported?"},{"location":"functions-quickstart/","text":"Functions Quickstart In this tutorial we are going to create a demo python funciton in a step-by-step manner and deploy it on the DeepMux platform. What are deepmux functions DeepMux functions are serverless functions that allow you to write complex data processing algorithms without caring about setting up complex infrastructure. Making sure deepmux-cli is installed Check out the Installation guide for detailed instructions. Setting up the project We recommend creating your project in a separate directory. For example: mkdir -p myproject cd myproject List function environments and choose the appropriate. Environments are used to define language you are going to use to code the function and provide some pre-installed libraries. deepmux env We are going to use python3.7 environment Then initialize the project with the following command: deepmux init This will create deepmux.yaml and .deepmuxignore files in your current directory. Contents of deepmux.yaml : name: <required, function name> env: <required, function env> python: call: <required, module:function to call> requirements: <optional, path to requirements.txt> Contents of .deepmuxignore : .deepmuxignore It is a standard ignore file and should contain ignore patterns. We are going to fill in name , env , call and requirements sections later. Implementing function Now it's time to implement the function itself. In this example we will implement a functions that simply reverses it's input. Create main.py file in the project directory and fill it with the following code: def reverse_function(data): return data[::-1] Functions written in Python accept bytes and return bytes . Let's save this function to a file main.py and add it as an entrypoint. You need to open deepmux.yaml and add main:reverse_function to the call: section. At this point deepmux.yaml would look like: name: myproject env: python3.7 python: call: main:reverse_function requirements: <optional, path to requirements.txt> And the project structure should look like: myproject/ myproject/deepmux.yaml myproject/main.py Add requirements (Optional) If you don't have any requirements just delete the last line from deepmux.yaml file and skip this section. You can add requirements for your function. Let's say we need numpy package in our function. Write requirements.txt file numpy==1.19.4 And add path to the file in your deepmux.yaml : name: myproject env: python3.7 python: call: main:reverse_function requirements: requirements.txt Uploading the function Once we've finished with the function, requirements and deepmux.yaml we are able to upload function to the platform via cli. deepmux upload Function will take some time to process. You can use deepmux list command to get your functions and their statuses or simply check your functions via the Web UI . Running the function Once your function has finished processing and is in READY state you can call it with an HTTP request. Here's an example using curl: curl -X POST \\ -H \"X-Token: <YOUR API TOKEN>\" \\ https://api.deepmux.com/v1/function/myproject/run \\ --data \"Hello!\" You should see the following on the screen: !olleH You also could run your function via cli: deepmux run --name myproject --data 'hello!' !olleh Done! Now you are ready to implement more complex functions and enjoy deploying them on the DeepMux platform.","title":"Functions Quickstart"},{"location":"functions-quickstart/#functions-quickstart","text":"In this tutorial we are going to create a demo python funciton in a step-by-step manner and deploy it on the DeepMux platform.","title":"Functions Quickstart"},{"location":"functions-quickstart/#what-are-deepmux-functions","text":"DeepMux functions are serverless functions that allow you to write complex data processing algorithms without caring about setting up complex infrastructure.","title":"What are deepmux functions"},{"location":"functions-quickstart/#making-sure-deepmux-cli-is-installed","text":"Check out the Installation guide for detailed instructions.","title":"Making sure deepmux-cli is installed"},{"location":"functions-quickstart/#setting-up-the-project","text":"We recommend creating your project in a separate directory. For example: mkdir -p myproject cd myproject List function environments and choose the appropriate. Environments are used to define language you are going to use to code the function and provide some pre-installed libraries. deepmux env We are going to use python3.7 environment Then initialize the project with the following command: deepmux init This will create deepmux.yaml and .deepmuxignore files in your current directory. Contents of deepmux.yaml : name: <required, function name> env: <required, function env> python: call: <required, module:function to call> requirements: <optional, path to requirements.txt> Contents of .deepmuxignore : .deepmuxignore It is a standard ignore file and should contain ignore patterns. We are going to fill in name , env , call and requirements sections later.","title":"Setting up the project"},{"location":"functions-quickstart/#implementing-function","text":"Now it's time to implement the function itself. In this example we will implement a functions that simply reverses it's input. Create main.py file in the project directory and fill it with the following code: def reverse_function(data): return data[::-1] Functions written in Python accept bytes and return bytes . Let's save this function to a file main.py and add it as an entrypoint. You need to open deepmux.yaml and add main:reverse_function to the call: section. At this point deepmux.yaml would look like: name: myproject env: python3.7 python: call: main:reverse_function requirements: <optional, path to requirements.txt> And the project structure should look like: myproject/ myproject/deepmux.yaml myproject/main.py","title":"Implementing function"},{"location":"functions-quickstart/#add-requirements-optional","text":"If you don't have any requirements just delete the last line from deepmux.yaml file and skip this section. You can add requirements for your function. Let's say we need numpy package in our function. Write requirements.txt file numpy==1.19.4 And add path to the file in your deepmux.yaml : name: myproject env: python3.7 python: call: main:reverse_function requirements: requirements.txt","title":"Add requirements (Optional)"},{"location":"functions-quickstart/#uploading-the-function","text":"Once we've finished with the function, requirements and deepmux.yaml we are able to upload function to the platform via cli. deepmux upload Function will take some time to process. You can use deepmux list command to get your functions and their statuses or simply check your functions via the Web UI .","title":"Uploading the function"},{"location":"functions-quickstart/#running-the-function","text":"Once your function has finished processing and is in READY state you can call it with an HTTP request. Here's an example using curl: curl -X POST \\ -H \"X-Token: <YOUR API TOKEN>\" \\ https://api.deepmux.com/v1/function/myproject/run \\ --data \"Hello!\" You should see the following on the screen: !olleH You also could run your function via cli: deepmux run --name myproject --data 'hello!' !olleh Done! Now you are ready to implement more complex functions and enjoy deploying them on the DeepMux platform.","title":"Running the function"},{"location":"client-libraries/http/","text":"DeepMux HTTP API You are here probably because you haven't found an SDK that suits your language / platform. Feel free to notify devs that you actually need a convenient library for your language by contacting us via dev@deepmux.com . Full documentation for HTTP API is availible at api.deepmux.com/docs/v1/ in swagger format, since it is much more useful than static docs.","title":"DeepMux HTTP API"},{"location":"client-libraries/http/#deepmux-http-api","text":"You are here probably because you haven't found an SDK that suits your language / platform. Feel free to notify devs that you actually need a convenient library for your language by contacting us via dev@deepmux.com . Full documentation for HTTP API is availible at api.deepmux.com/docs/v1/ in swagger format, since it is much more useful than static docs.","title":"DeepMux HTTP API"},{"location":"client-libraries/python/","text":"DeepMux Python client library deepmux is a PaaS solution to effortlessly deploy trained machine learning models on the cloud and generate predictions without setting up any hardware. At the moment only pytorch models are supported. API Token To use deepmux-python you will need an API token. You can always get one here: app.deepmux.com/api_key Installation pip install deepmux Creating models You can always create a model using create_model function. from deepmux import create_model There are multiple parameters you need to pass to create_model function: pytorch_model : Pre-trained pytorch model. Once the model is uploaded model_name : Model name by which you can refer to it once it is uploaded. input_shape : List of input tensor shapes for each model input. A typical model would work with input shape of [[1, 3, 224, 224]] . Note the nested list, if your model has multiple inputs, you can pass input shapes in the topmost list like this: [[2, 2], [1, 3]] that would stand for two inputs of sizes 2x2 and 1x3 respectively. output_shape : List of output tensor shapes for each model input. Semantics are the same as the same as for input_shape . Below is an artificial example of creating a model with two inputs and a single output: import torch from deepmux import create_model class MyNet(torch.nn.Module): def __init__(self): super().__init__() self.model1 = torch.nn.Sequential( torch.nn.Linear(2, 4), torch.nn.ReLU() ) self.model2 = torch.nn.Sequential( torch.nn.Linear(8, 4), ) def forward(self, x, y): x1 = self.model1(x) y1 = self.model1(y) return self.model2(torch.cat((x1, y1), 0)) net = MyNet() # Train or load weights # ... token = '<YOUR API TOKEN>' deepmux_model = create_model( net, model_name='my_net', input_shape=[[2], [2]], output_shape=[4], token=token) Getting models by name Once the model was created you can refer to the model by it's name. This function is useful in production environment since you don't need to know anything about the model apart from it's name to execute it. Going forward with the example from previous point: from deepmux import get_model token = '<YOUR API TOKEN>' deepmux_model = get_model('my_net', token) Running models After initializing your model with create_model or get_model you can run the model. All computations will be performed on deepmux infrastucture. To run the model you must pass a numpy.ndarray for each input. Shapes of input tensors must match model input shapes. Note that dtype of the input data must match the data type of the uploaded model. Again, with our MyNet example: model_input = [ np.array([2.0, 3.0], dtype=np.float32), np.array([2.0, 3.0], dtype=np.float32) ] output = deepmux_model.run(*model_input) Example from the tutorial import torch from deepmux import create_model # Initialize a PyTorch model class MyNet(torch.nn.Module): def __init__(self): super().__init__() self.model1 = torch.nn.Sequential( torch.nn.Linear(2, 4), torch.nn.ReLU() ) self.model2 = torch.nn.Sequential( torch.nn.Linear(8, 4), ) def forward(self, x, y): x1 = self.model1(x) y1 = self.model1(y) return self.model2(torch.cat((x1, y1), 0)) # Not training the model and using default weights here net = MyNet() # Upload model to DeepMux token = '<YOUR API TOKEN>' deepmux_model = create_model( net, model_name='my_net', input_shape=[[2], [2]], output_shape=[4], token=token) # get_model call is redundant here since create_model returns a reference to the model # deepmux_model = get_model('my_net', token) # Run model model_input = [ np.array([2.0, 3.0], dtype=np.float32), np.array([2.0, 3.0], dtype=np.float32) ] output = deepmux_model.run(*model_input) Example on a model from PyTorch Hub Below is an example of a complete ImageNet classifier achieved with pretrained squeezenet model. Creating the model import numpy as np import torch from deepmux import create_model token = \"<YOUR API TOKEN>\" pytorch_model = torch.hub.load('pytorch/vision:v0.5.0', 'squeezenet1_0', pretrained=True) create_model( pytorch_model, model_name='my_squeezenet', input_shape=[1, 3, 227, 227], output_shape=[1, 1000], token=token) Running the model # Note: we no longer need pytorch from deepmux import get_model token = \"<YOUR API TOKEN>\" deepmux_model = get_model('my_squeezenet', token) dummy_input = np.zeros([1, 3, 227, 227], dtype=np.float32) output = deepmux_model.run(dummy_input) Colab demo Try our demo or contact us at dev@deepmux.com if you have any questions left.","title":"DeepMux Python client library"},{"location":"client-libraries/python/#deepmux-python-client-library","text":"deepmux is a PaaS solution to effortlessly deploy trained machine learning models on the cloud and generate predictions without setting up any hardware. At the moment only pytorch models are supported.","title":"DeepMux Python client library"},{"location":"client-libraries/python/#api-token","text":"To use deepmux-python you will need an API token. You can always get one here: app.deepmux.com/api_key","title":"API Token"},{"location":"client-libraries/python/#installation","text":"pip install deepmux","title":"Installation"},{"location":"client-libraries/python/#creating-models","text":"You can always create a model using create_model function. from deepmux import create_model There are multiple parameters you need to pass to create_model function: pytorch_model : Pre-trained pytorch model. Once the model is uploaded model_name : Model name by which you can refer to it once it is uploaded. input_shape : List of input tensor shapes for each model input. A typical model would work with input shape of [[1, 3, 224, 224]] . Note the nested list, if your model has multiple inputs, you can pass input shapes in the topmost list like this: [[2, 2], [1, 3]] that would stand for two inputs of sizes 2x2 and 1x3 respectively. output_shape : List of output tensor shapes for each model input. Semantics are the same as the same as for input_shape . Below is an artificial example of creating a model with two inputs and a single output: import torch from deepmux import create_model class MyNet(torch.nn.Module): def __init__(self): super().__init__() self.model1 = torch.nn.Sequential( torch.nn.Linear(2, 4), torch.nn.ReLU() ) self.model2 = torch.nn.Sequential( torch.nn.Linear(8, 4), ) def forward(self, x, y): x1 = self.model1(x) y1 = self.model1(y) return self.model2(torch.cat((x1, y1), 0)) net = MyNet() # Train or load weights # ... token = '<YOUR API TOKEN>' deepmux_model = create_model( net, model_name='my_net', input_shape=[[2], [2]], output_shape=[4], token=token)","title":"Creating models"},{"location":"client-libraries/python/#getting-models-by-name","text":"Once the model was created you can refer to the model by it's name. This function is useful in production environment since you don't need to know anything about the model apart from it's name to execute it. Going forward with the example from previous point: from deepmux import get_model token = '<YOUR API TOKEN>' deepmux_model = get_model('my_net', token)","title":"Getting models by name"},{"location":"client-libraries/python/#running-models","text":"After initializing your model with create_model or get_model you can run the model. All computations will be performed on deepmux infrastucture. To run the model you must pass a numpy.ndarray for each input. Shapes of input tensors must match model input shapes. Note that dtype of the input data must match the data type of the uploaded model. Again, with our MyNet example: model_input = [ np.array([2.0, 3.0], dtype=np.float32), np.array([2.0, 3.0], dtype=np.float32) ] output = deepmux_model.run(*model_input)","title":"Running models"},{"location":"client-libraries/python/#example-from-the-tutorial","text":"import torch from deepmux import create_model # Initialize a PyTorch model class MyNet(torch.nn.Module): def __init__(self): super().__init__() self.model1 = torch.nn.Sequential( torch.nn.Linear(2, 4), torch.nn.ReLU() ) self.model2 = torch.nn.Sequential( torch.nn.Linear(8, 4), ) def forward(self, x, y): x1 = self.model1(x) y1 = self.model1(y) return self.model2(torch.cat((x1, y1), 0)) # Not training the model and using default weights here net = MyNet() # Upload model to DeepMux token = '<YOUR API TOKEN>' deepmux_model = create_model( net, model_name='my_net', input_shape=[[2], [2]], output_shape=[4], token=token) # get_model call is redundant here since create_model returns a reference to the model # deepmux_model = get_model('my_net', token) # Run model model_input = [ np.array([2.0, 3.0], dtype=np.float32), np.array([2.0, 3.0], dtype=np.float32) ] output = deepmux_model.run(*model_input)","title":"Example from the tutorial"},{"location":"client-libraries/python/#example-on-a-model-from-pytorch-hub","text":"Below is an example of a complete ImageNet classifier achieved with pretrained squeezenet model.","title":"Example on a model from PyTorch Hub"},{"location":"client-libraries/python/#creating-the-model","text":"import numpy as np import torch from deepmux import create_model token = \"<YOUR API TOKEN>\" pytorch_model = torch.hub.load('pytorch/vision:v0.5.0', 'squeezenet1_0', pretrained=True) create_model( pytorch_model, model_name='my_squeezenet', input_shape=[1, 3, 227, 227], output_shape=[1, 1000], token=token)","title":"Creating the model"},{"location":"client-libraries/python/#running-the-model","text":"# Note: we no longer need pytorch from deepmux import get_model token = \"<YOUR API TOKEN>\" deepmux_model = get_model('my_squeezenet', token) dummy_input = np.zeros([1, 3, 227, 227], dtype=np.float32) output = deepmux_model.run(dummy_input)","title":"Running the model"},{"location":"client-libraries/python/#colab-demo","text":"Try our demo or contact us at dev@deepmux.com if you have any questions left.","title":"Colab demo"}]}